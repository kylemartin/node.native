#!/usr/bin/env python
import optparse
import os
import pprint
import re
import subprocess
import sys

CC = os.environ.get('CC', 'cc')

root_dir = os.path.dirname(__file__)

# parse our options
parser = optparse.OptionParser()

parser.add_option("--debug",
    action="store_true",
    dest="debug",
    help="Also build debug build")

parser.add_option("--dest-cpu",
    action="store",
    dest="dest_cpu",
    help="CPU architecture to build for. Valid values are: arm, ia32, x64")

parser.add_option("--cc",
	action="store",
	dest="cc",
	help="specify C compiler (the CC environment variable)")
	
parser.add_option("--cxx",
	action="store",
	dest="cxx",
	help="specify C++ compiler (the CXX environment variable)")
	
(options, args) = parser.parse_args()


def b(value):
  """Returns the string 'true' if value is truthy, 'false' otherwise."""
  if value:
    return 'true'
  else:
    return 'false'


def pkg_config(pkg):
  cmd = os.popen('pkg-config --libs %s' % pkg, 'r')
  libs = cmd.readline().strip()
  ret = cmd.close()
  if (ret): return None

  cmd = os.popen('pkg-config --cflags %s' % pkg, 'r')
  cflags = cmd.readline().strip()
  ret = cmd.close()
  if (ret): return None

  return (libs, cflags)


def host_arch_cc():
  """Host architecture check using the CC command."""

  p = subprocess.Popen(CC.split() + ['-dM', '-E', '-'],
                       stdin=subprocess.PIPE,
                       stdout=subprocess.PIPE,
                       stderr=subprocess.PIPE)
  p.stdin.write('\n')
  out = p.communicate()[0]

  out = str(out).split('\n')

  k = {}
  for line in out:
    import shlex
    lst = shlex.split(line)
    if len(lst) > 2:
      key = lst[1]
      val = lst[2]
      k[key] = val

  matchup = {
    '__x86_64__'  : 'x64',
    '__i386__'    : 'ia32',
    '__arm__'     : 'arm',
  }

  rtn = 'ia32' # default

  for i in matchup:
    if i in k and k[i] != '0':
      rtn = matchup[i]
      break

  return rtn


def host_arch_win():
  """Host architecture check using environ vars (better way to do this?)"""

  arch = os.environ.get('PROCESSOR_ARCHITECTURE', 'x86')

  matchup = {
    'AMD64'  : 'x64',
    'x86'    : 'ia32',
    'arm'    : 'arm',
  }

  return matchup.get(arch, 'ia32')


def host_arch():
  """Host architecture. One of arm, ia32 or x64."""
  if os.name == 'nt':
    arch = host_arch_win()
  else:
    arch = host_arch_cc()
  return arch


def target_arch():
  return host_arch()


def gcc_version():
  try:
    proc = subprocess.Popen([CC, '-v'], stderr=subprocess.PIPE)
  except OSError:
    return None
  # TODO parse clang output
  version = proc.communicate()[1].split('\n')[-2]
  match = re.match('gcc version (\d+)\.(\d+)\.(\d+)', version)
  if not match: return None
  return ['LLVM' in version] + map(int, match.groups())


def configure_native(o):
  o['variables']['host_arch'] = host_arch()
  o['variables']['target_arch'] = options.dest_cpu or target_arch()
  o['default_configuration'] = 'Debug' if options.debug else 'Release'
  o['cflags'] = []

output = {
  'variables': {},
  'include_dirs': [],
  'libraries': [],
  'defines': [],
  'cflags': [],
}

configure_native(output)

# variables should be a root level element,
# move everything else to target_defaults
variables = output['variables']
del output['variables']
output = {
  'variables': variables,
  'target_defaults': output
}
pprint.pprint(output, indent=2)

def write(filename, data):
  filename = os.path.join(root_dir, filename)
  print "creating ", filename
  f = open(filename, 'w+')
  f.write(data)

write('config.gypi', "# Do not edit. Generated by the configure script.\n" +
  pprint.pformat(output, indent=2) + "\n")

write('config.mk', "# Do not edit. Generated by the configure script.\n" 
  + ("export BUILDTYPE=%s\n" % ('Debug' if options.debug else 'Release'))
  + ("export CC=%s\n" % (options.cc or os.environ.get('CC', '')) if os.environ.has_key('CC') else "")
  + ("export CXX=%s\n" % (options.cxx or os.environ.get('CXX', '')) if os.environ.has_key('CXX') else "")
  )

if os.name == 'nt':
  subprocess.call(['python', 'tools/gyp_native', '-f', 'msvs',
                                               '-G', 'msvs_version=2010'])
else:
  subprocess.call(['tools/gyp_native', '-f', 'make'])
